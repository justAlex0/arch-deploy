#+TITLE:     Arch deploy script
#+AUTHOR:    justAlex0
#+PROPERTY: header-args :tangle arch-deploy.bash
#+auto_tangle: t

Yet another simple script for automated installation of Arch Linux.

This script basically follows the official Installation Guide from ArchWiki but with some additions.

It can install Arch with GRUB/Unified kernel image and with non-encrypted or encrypted root partition /(dm-crypt with LUKS)/

This ~README.org~ may help those who install Arch manually or make their own script.

*** Disclaimer
It's not really suited to be used for public, since there's a nicer tool called ~archinstall~. I made this script as a tool that suits my needs and deploys the OS with my setup and configs.
Though I hope somebody find in here something helpfull.

* Installation
Most likely Arch image doesn't ship ~git~ so it needs to be installed first.
#+begin_src bash :tangle no
pacman -Sy git
#+end_src
Then clone the repository

* Usage
#+begin_src bash :tangle no
arch-deploy.bash --help
#+end_src

* User-defined variables
These variables you may change if not going to use options
#+begin_src bash
#!/usr/bin/env bash
##################################################### User-defined variables
# If empty the user will not be created
USER="alex"

HOST_NAME="arch"

# What group of packages to install
# Options: minimal | full
SETUP="minimal"

# What Display server and corresponding desktop utils to install
# Only works if SETUP == "full"
# Options: X | Wayland
DISPLAY_SERVER="X"

# Bootloader:
# Options: grub | UKI (Unified kernel image)
# If empty the Bootloader will not be installed
BOOTLOADER="UKI"

# If empty timezone will not be set
# It appends path to /usr/share/zoneinfo/ to symlink with /etc/localtime
TIMEZONE="Europe/Berlin"

# Will be used by reflector
MIRRORLIST="Germany,Netherlands,Poland"

# Will create a swap file in the root directory
ENABLE_SWAP_FILE=false
SWAP_FILE_SIZE=16 # GiB

# dm-crypt with LUKS
ENABLE_FULL_DRIVE_ENCRYPTION=false

# Will prefer package cache on the host
IS_INSTALLING_FROM_EXISTING_ARCH=false

# At the end of installation it will be used for cloning the provided repo
# and installing its content through GNU util "stow"
# If empty this will be ignored
GITCLONE="https://gitlab.com/justAlex0/dot-files"

ESP="/boot/efi"
STAGE="fresh"
############################################################################
#+end_src

* Script-defined variables
These are global variables
#+begin_src bash
SCRIPT_PATH=$(realpath -s "${BASH_SOURCE[0]}")
SCRIPT_NAME=$(basename "$SCRIPT_PATH")
SCRIPT_DIR=$(dirname "$SCRIPT_PATH")

readonly SCRIPT_PATH SCRIPT_NAME SCRIPT_DIR ESP
declare -a PKG AUR_PKG MODULES KERNEL_PARAMS
#+end_src

* Miscellaneous Functions
** Print Help
#+begin_src bash
function help {
    printf "The script installs Arch Linux

Usage:
    %s <drive> [OPTIONS]

Options:
    -S, --stage=NAME        Specify the stage of installing.
                            fresh|bootloader
                            default: fresh
    -u, --user=NAME         User name
    -h, --hostname=NAME     Host name
    -g, --setup=NAME        Group of packages
                            minimal|full
                            default: minimal
    -d, --display=NAME      Display server that will be used if --setup=full
                            X|Wayland
                            default: X
    -b, --bootloader=NAME   Bootloader to install
                            UKI|Grub
                            default: UKI
    -s, --swap              Whether to use swap file
    -e, --encryption        Whether to use full drive encryption
    -a, --archhost          Whether installing from arch host to use its package cache

" "$SCRIPT_NAME"
   exit 0
}
#+end_src

** Output log
#+begin_src bash
BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
ESC=$(tput sgr0)
readonly BOLD RED GREEN YELLOW BLUE ESC

function log {
    case "$2" in
        "err")
            printf "%s[%s]%s\n" "${BOLD}${RED}" "$1" "${ESC}" >&2
            ;;
        "warn")
            printf "%s[%s]%s\n" "${BOLD}${YELLOW}" "$1" "${ESC}"
            ;;
        *)
            printf "%s[%s]%s\n" "${BOLD}${GREEN}" "$1" "${ESC}"
            ;;
    esac
    if [[ -n "$3" ]]; then
        exit "$3"
    fi
}
#+end_src

** Get the Names of Partition Parts
This extends sda to sda1 and sda2, nvme0n1 to nvme0n1p1 and nvme0n1p2 and will be used next by [[#drive-partitioning][Drive Partitioning]] and during bootloader's installation.
#+begin_src bash
function ExtendDriveName {
    if lsblk --nodeps --noheadings --paths --raw --output NAME | grep -x "$DRIVE" &> /dev/null; then
        case $DRIVE in
            *"sd"* | *"vd"* )
                P1="1"
                P2="2"
                #P3="3"
                ;;
            *"nvme"* )
                P1="p1"
                P2="p2"
                #P3="p3"
                ;;
            * )
                log "Only HDD or SSD. Aborting." err
                help
                ;;
        esac
        readonly P1 P2
    else
        log "Wrong \"$1\" drive. Aborting." err
        help
    fi
}
#+end_src

** Output Summary
#+begin_src bash
function summary {
    if ! check_uefi; then
        if [[ "$BOOTLOADER" != "grub" ]]; then
            log "UEFI is not supported." err
            log "Grub will be installed instead." warn
            BOOTLOADER="grub"
            [[ $ENABLE_FULL_DRIVE_ENCRYPTION ]] && log "BIOS + grub + full drive encryption is not supported in this script because I personally would never use this combination and so I didnt want to spend more time on it" err 1
        fi
    fi
    if [[ -z "$TIMEZONE" ]]; then
        log "Timezone is not provided. \"UTC\" will be used." err
        TIMEZONE="UTC"
    fi

    echo "Summary:"
    echo "                       Drive: [${BOLD}${YELLOW}${DRIVE}${ESC}]"
    echo "                        User: [${YELLOW}${USER}${ESC}]"
    echo "                   Host name: [${YELLOW}${HOST_NAME}${ESC}]"
    echo "                       Setup: [${YELLOW}${SETUP}${ESC}]"
    echo "              Display Server: [${YELLOW}${DISPLAY_SERVER}${ESC}]"
    echo "                  Bootloader: [${YELLOW}${BOOTLOADER}${ESC}]"
    echo "                    Timezone: [${YELLOW}${TIMEZONE}${ESC}]"
    echo "                  Mirrorlist: [${YELLOW}${MIRRORLIST}${ESC}]"
    echo "            Enable swap file: [${YELLOW}${ENABLE_SWAP_FILE}${ESC}]"
    echo "              Swap file size: [${YELLOW}${SWAP_FILE_SIZE}${ESC}]"
    echo "Enable full drive encryption: [${YELLOW}${ENABLE_FULL_DRIVE_ENCRYPTION}${ESC}]"
    echo "Is installing from arch host: [${YELLOW}${IS_INSTALLING_FROM_EXISTING_ARCH}${ESC}]"
    echo "         Repository to clone: [${YELLOW}${GITCLONE}${ESC}]"

    local answer
    read -rp "Continue? y/n " answer
    echo
    [[ "$answer" != "y" ]] && exit 1

    local rpass1 rpass2
    read -srp "Enter root password" rpass1
    echo
    [[ -z "$rpass1" ]] && log "no password" err 1
    read -srp "Enter root password again" rpass2
    echo
    [[ "$rpass1" != "$rpass2" ]] && log "wrong passwords" err 1
    ROOT_PASSWORD="$rpass1"

    local upass
    read -srp "Enter user password (might be empty)" upass
    echo
    USER_PASSWORD="$upass"

    if $ENABLE_FULL_DRIVE_ENCRYPTION; then
        local epass1 epass2
        read -srp "Enter encryption password" epass1
        echo
        [[ -z "$epass1" ]] && log "no password" err 1
        read -srp "Enter encryption password again" epass2
        echo
        [[ "$epass1" != "$epass2" ]] && log "wrong passwords" err 1
        PASSPHRASE_FOR_ENCRYPTION="$epass1"
    fi

    readonly DRIVE USER HOST_NAME ROOT_PASSWORD USER_PASSWORD SETUP BOOTLOADER TIMEZONE MIRRORLIST
    readonly ENABLE_SWAP_FILE SWAP_FILE_SIZE ENABLE_FULL_DRIVE_ENCRYPTION PASSPHRASE_FOR_ENCRYPTION
    readonly GITCLONE
}
#+end_src

** Bootloader
#+begin_src bash
source "$SCRIPT_DIR"/.bootloaders.bash
function deploy_bootloader {
    if [[ -n "$BOOTLOADER" ]]; then
        case "$BOOTLOADER" in
            "grub")
                bootloader-grub
                ;;
            "UKI")
                bootloader-unified-kernel-image
                ;;
        esac
    fi
}
#+end_src

** Hardwares Checks
*** Check UEFI
#+begin_src bash
function check_uefi {
    [ -d /sys/firmware/efi/ ]
}
#+end_src

*** Check CPU
#+begin_src bash
function check_cpu {
    local CPU_VENDOR
    CPU_VENDOR=$(awk -F ": " '/vendor_id/ {print $NF; exit}' /proc/cpuinfo)
    case "$CPU_VENDOR" in
        "GenuineIntel" )
            PKG+=(intel-ucode xf86-video-intel)
            ;;
        "AuthenticAMD" )
            PKG+=(amd-ucode xf86-video-amdgpu)
            ;;
    esac
}
#+end_src

*** Check GPU
#+begin_src bash
function check_gpu {
    local GRAPHICS
    GRAPHICS=$(lspci -v | grep -A1 -e VGA -e 3D)
    case ${GRAPHICS^^} in
        *NVIDIA* )
            PKG+=(linux-headers)
            [[ "$SETUP" == "full" ]] && PKG+=(linux-zen-headers)
            PKG+=(nvidia-dkms nvidia-utils nvidia-settings)
            PKG+=(vulkan-icd-loader)
            PKG+=(nvtop)
            MODULES+=(nvidia nvidia_modeset nvidia_uvm nvidia_drm)
            ;;
        *AMD* | *ATI* )
            PKG+=(xf86-video-ati libva-mesa-driver vulkan-radeon)
            PKG+=(vulkan-icd-loader)
            PKG+=(nvtop)
            ;;
        *INTEL* )
            PKG+=(libva-intel-driver intel-media-driver vulkan-intel)
            PKG+=(vulkan-icd-loader)
            ;;
    esac
}
#+end_src
Reference:
- [[https://wiki.archlinux.org/title/NVIDIA/Tips_and_tricks#Kernel_module_parameters][Arch Wiki: NVIDIA/Kernel module parameters]]

* Drive Partitioning
** Partition the Drive
#+begin_src bash
function partitioning {
    trap "readonly STATUS_PARTITIONING=error" ERR
    log "Partitioning the drive"

    log "Clearing existing partition tables"
    sgdisk "$DRIVE" -Z
    if check_uefi; then
        log "Partitioning 256M for EFI and the rest for Linux"
        sgdisk "$DRIVE" --align-end --new=1:0:+256M --typecode=1:ef00 --largest-new=2
    else
        log "Partitioning 256M for BIOS and the rest for Linux"
        sgdisk "$DRIVE" --align-end --new=1:0:+256M --typecode=1:ef02 --largest-new=2
    fi
    log "Partition table:"
    sgdisk "$DRIVE" -p

    [[ "$STATUS_PARTITIONING" == "error" ]] && log "Errors acquired during Partitioning the drive." err 1
}
#+end_src

** Non-Crypt
*** Format and Mount the Partitions
#+begin_src bash
function formatting {
    trap "readonly STATUS_FORMATING=error" ERR
    log "Formatting the partitions (non-crypt)"
    yes | mkfs.fat -F 32 "$DRIVE$P1"
    yes | mkfs.ext4 "$DRIVE$P2"

    log "Mounting the partitions"
    mount "$DRIVE$P2" /mnt
    mkdir -p /mnt"$ESP"
    mount "$DRIVE$P1" /mnt"$ESP"

    [[ "$STATUS_FORMATING" == "error" ]] && log "Errors acquired during Formatting the partitions (non-crypt)." err 1
}
#+end_src

** Crypt
*** Securely wipe the drive before Partitioning and Encrypting the drive
#+begin_src bash
function drive-preparation {
    log "Creating a temporary encrypted container on the drive"
    echo "YES" | cryptsetup open --type plain --key-file /dev/urandom "$DRIVE" to_be_wiped || exit 1
    log "Wiping it"
    dd if=/dev/zero of=/dev/mapper/to_be_wiped bs=1M status=progress
    log "Closing the container"
    cryptsetup close to_be_wiped
}
#+end_src
Reference:
- [[https://wiki.archlinux.org/title/Dm-crypt/Drive_preparation][Arch Wiki: dm-crypt/Drive preparation]]

*** Format and Mount the Partitions
#+begin_src bash
function formatting-crypt {
    trap "readonly STATUS_FORMATTING_CRYPT=error" ERR
    log "Formatting the partitions (crypt)"

    yes | mkfs.fat -F 32 "$DRIVE$P1"

    log "Formatting LUKS partitions"
    echo "$PASSPHRASE_FOR_ENCRYPTION" | cryptsetup --verbose luksFormat "$DRIVE$P2"
    log "Unlocking/Mapping LUKS partitions with the device mapper"
    if [[ "$DRIVE" == *"nvme"*  ]]; then
        # See the reference
        echo "$PASSPHRASE_FOR_ENCRYPTION" | cryptsetup --perf-no_read_workqueue --perf-no_write_workqueue --persistent open "$DRIVE$P2" root
    else
        echo "$PASSPHRASE_FOR_ENCRYPTION" | cryptsetup open "$DRIVE$P2" root
    fi
    yes | mkfs.ext4 /dev/mapper/root

    log "Mounting the partitions"
    mount /dev/mapper/root /mnt
    mkdir -p /mnt"$ESP"
    mount "$DRIVE$P1" /mnt"$ESP"

    [[ "$STATUS_FORMATTING_CRYPT" == "error" ]] && log "Errors acquired during Formatting the partitions (crypt)." err 1
}
#+end_src
References:
- [[https://wiki.archlinux.org/title/Dm-crypt/Device_encryption#Encrypting_devices_with_cryptsetup][Arch Wiki: Encrypting devices with cryptsetup]]
- [[https://wiki.archlinux.org/title/Dm-crypt/Encrypting_an_entire_system#LUKS_on_a_partition][Arch Wiki: LUKS on a partition]]
- [[https://wiki.archlinux.org/title/Dm-crypt/Specialties#Disable_workqueue_for_increased_solid_state_drive_(SSD)_performance][Arch Wiki: Disable workqueue for increased solid state drive (SSD) performance]]

* Deploying Functions
** Creating a Swap File
#+begin_src bash
function deploy_swap {
    trap "readonly STATUS_SWAP=error" ERR
    if $ENABLE_SWAP_FILE; then
        log "Creating a swap file"

        dd if=/dev/zero of=/mnt/swapfile bs=1M count="$SWAP_FILE_SIZE"GiB status=progress
        arch-chroot /mnt chmod 0600 /swapfile
        arch-chroot /mnt mkswap -U clear /swapfile
        # arch-chroot /mnt swapon /swapfile

        {
            echo -e "\n#Swapfile"
            echo "/swapfile none swap defaults 0 0"
        } >> /mnt/etc/fstab

        sed -i "s|fsck|resume fsck|" /mnt/etc/mkinitcpio.conf

        # See the reference
        SWAP_DEVICE=$(findmnt -no UUID -T /mnt/swapfile)
        SWAP_FILE_OFFSET=$(filefrag -v /mnt/swapfile | awk '$1=="0:" {print substr($4, 1, length($4)-2)}')
        KERNEL_PARAMS+=(resume="$SWAP_DEVICE" resume_offset="$SWAP_FILE_OFFSET")
    fi

    log "Generating fstab"
    genfstab -U /mnt > /mnt/etc/fstab
}
#+end_src
References:
- [[https://wiki.archlinux.org/title/Power_management/Suspend_and_hibernate][Arch Wiki: Hibernation into swap file]]

** Configuring localtime
#+begin_src bash
function deploy_localtime {
    trap "readonly STATUS_LOCALTIME=error" ERR
    log "Configuring localtime"
    [[ -n "$TIMEZONE" ]] && arch-chroot /mnt ln -sf /usr/share/zoneinfo/"$TIMEZONE" /etc/localtime
    arch-chroot /mnt hwclock --systohc
}
#+end_src

** Configuring localization
#+begin_src bash
function deploy_localization {
    trap "readonly STATUS_LOCALIZATION=error" ERR
    log "Configuring localization"
    sed -Ei "s|^#en_US.UTF-8 UTF-8|en_US.UTF-8 UTF-8|" /mnt/etc/locale.gen
    arch-chroot /mnt locale-gen
    {
        echo "LANG=en_US.UTF-8"
        echo "LC_ALL=en_US.UTF-8"
    } > /mnt/etc/locale.conf
}
#+end_src

** Network configuration
#+begin_src bash
function deploy_network {
    trap "readonly STATUS_NETWORK=error" ERR
    log "Network configuration"
    echo "$HOST_NAME" > /mnt/etc/hostname
    {
        echo "127.0.0.1        localhost"
        echo "::1              localhost"
        echo "127.0.1.1        $HOST_NAME"
    } > /mnt/etc/hosts
    arch-chroot /mnt systemctl enable NetworkManager.service
    {
        echo "[device]"
        echo "wifi.scan-rand-mac-address=no"
    } > /mnt/etc/NetworkManager/NetworkManager.conf
    mkdir -p /mnt/etc/iwd
    {
        echo "[General]"
        echo "EnableNetworkConfiguration=True"
    } > /mnt/etc/iwd/main.conf
    if [[ -x /mnt/usr/bin/nft ]]; then
        arch-chroot /mnt systemctl enable nftables.service
    fi
}
#+end_src
References:
- [[https://bbs.archlinux.org/viewtopic.php?id=250604][Arch Forum: Troubleshooting unstable wifi]]
- [[https://wiki.archlinux.org/title/Iwd#No_DHCP_in_AP_mode][Arch Wiki: No DHCP in AP mode]]

** AppArmor enabling
#+begin_src bash
function deploy_apparmor {
    if [[ -x /mnt/usr/bin/aa-status ]]; then
        KERNEL_PARAMS+=(lsm=landlock,lockdown,yama,integrity,apparmor,bpf)
        arch-chroot /mnt systemctl enable apparmor.service
    fi
}
#+end_src

** Users and Passwords
#+begin_src bash
function deploy_users {
    trap "readonly STATUS_USERS=error" ERR
    log "Setting root password"
    arch-chroot /mnt /bin/bash -c "echo root:$ROOT_PASSWORD | chpasswd" || log "Error - root password" err

    if [[ -n "$USER" ]]; then
        log "Creating user $USER"
        arch-chroot /mnt useradd --create-home --groups wheel "$USER" || log "Error - user" err

        if [[ -n "$USER_PASSWORD" ]]; then
            log "Setting user password"
            arch-chroot /mnt /bin/bash -c "echo $USER:$USER_PASSWORD | chpasswd" || log "Error - user password" err
        else
            arch-chroot /mnt passwd -d "$USER"
        fi
    fi

    if [[ -x /mnt/usr/bin/doas ]]; then
        log "Configuring doas"
        {
            echo "permit nopass root"
            echo -e "permit :wheel\n"
        } > /mnt/etc/doas.conf
        arch-chroot /mnt chmod -c 0400 /etc/doas.conf
        arch-chroot /mnt ln -sf /usr/bin/doas /usr/bin/sudo
    else
        sed -Ei "s|^#?%wheel ALL=(ALL:ALL) ALL|%wheel ALL=(ALL:ALL) ALL|" /mnt/etc/sudoers
    fi
}
#+end_src

** Generating initramfs images
#+begin_src bash
function deploy_initramfs {
    trap "readonly STATUS_INITRAMFS=error" ERR
    log "Generating initramfs images"

    # See the reference
    {
        echo "# Do not load watchdogs module for increasing perfomance"
        echo "blacklist iTCO_wdt"
    } > /mnt/etc/modprobe.d/nowatchdog.conf
    sed -Ei 's|^#?FILES=.*|FILES=(/etc/modprobe.d/nowatchdog.conf)|' /mnt/etc/mkinitcpio.conf

    if $ENABLE_FULL_DRIVE_ENCRYPTION; then
        sed -i "s|filesystems|encrypt filesystems|" /mnt/etc/mkinitcpio.conf
        MODULES+=(dm_crypt)
    fi

    [[ -n "$MODULES" ]] && sed -Ei "s|^MODULES=.*|MODULES=(${MODULES[*]})|" /mnt/etc/mkinitcpio.conf
    if [[ -x /usr/bin/lz4 ]]; then
        # because lz4 is faster
        sed -Ei "s|^#COMPRESSION=\"lz4\"|COMPRESSION=\"lz4\"|" /mnt/etc/mkinitcpio.conf
        sed -Ei "s|^#COMPRESSION_OPTIONS=.*|COMPRESSION_OPTIONS=(-9)|" /mnt/etc/mkinitcpio.conf
    fi

    arch-chroot /mnt mkinitcpio -p linux
}
#+end_src
References:
- [[https://wiki.archlinux.org/title/improving_performance#Watchdogs][Arch Wiki: Watchdogs]]

** Cloning personal dot-files
#+begin_src bash
function deploy_dotfiles {
    trap "readonly STATUS_DOTFILES=error" ERR
    if [[ -n "$GITCLONE" && -n "$USER" ]]; then
        log "Cloning dot-files"
        cd /mnt/home/"$USER" || return
        git clone "$GITCLONE"
        arch-chroot /mnt chown "$USER":"$USER" -R "/home/$USER"
    fi
}
#+end_src

** Unmount
#+begin_src bash
function deploy_unmount {
    log "Unmounting /mnt"
    # [[ $ENABLE_SWAP_FILE ]] && swapoff /mnt/swapfile
    umount -R /mnt || log "Error - Failed to umount /mnt" err
    if $ENABLE_FULL_DRIVE_ENCRYPTION; then
        log "Closing the encrypted partition"
        cryptsetup close root || log "Error - Failed to close the encrypted partition" err
    fi
}
#+end_src

** Check if any errors acquired
#+begin_src bash
function check_errors {
    [[ "$STATUS_LOCALTIME" == "error" ]] && log "Errors acquired during Localtime configuration." err
    [[ "$STATUS_LOCALIZATION" == "error" ]] && log "Errors acquired during Localization configuration." err
    [[ "$STATUS_NETWORK" == "error" ]] && log "Errors acquired during Network configuration." err
    [[ "$STATUS_USERS" == "error" ]] && log "Errors acquired during Creating user and setting passwords." err
    [[ "$STATUS_SWAP" == "error" ]] && log "Errors acquired during Creating a swap file." err
    [[ "$STATUS_INITRAMFS" == "error" ]] && log "Errors acquired during Generating of initramfs images." err
    [[ "$STATUS_DOTFILES" == "error" ]] && log "Errors acquired during Cloning dot-files." err
    [[ "$STATUS_BOOTLOADER" == "error" ]] && log "Errors acquired during Installation of the bootloader." err
}
#+end_src

* Begin Deploying
#+begin_src bash
function deploy_init {
    summary

    log "Testing ethernet connection"
    ping archlinux.org -c 2 &> /dev/null || log "No ethernet connection. Aborting." err 1

    log "Updating the system clock"
    timedatectl set-ntp true

    if $ENABLE_FULL_DRIVE_ENCRYPTION; then
        drive-preparation
        partitioning
        formatting-crypt
    else
        partitioning
        formatting
    fi

    sed -Ei 's|^#?Color|Color|' /etc/pacman.conf
    sed -Ei "s|^#?ParallelDownloads.*|ParallelDownloads = 3|" /etc/pacman.conf
    sed -zi 's|#\[multilib\]\n#Include = \/etc\/pacman.d\/mirrorlist|\[multilib\]\nInclude = \/etc\/pacman.d\/mirrorlist|' /etc/pacman.conf

    source "$SCRIPT_DIR"/.package-list.bash
    check_cpu
    [[ "$SETUP" == "full" ]] && check_gpu
    if $IS_INSTALLING_FROM_EXISTING_ARCH; then
        pacstrap -c /mnt "${PKG[@]}" || log "Problems with ethernet connection. Aborting." err 1
    else
        pacstrap /mnt "${PKG[@]}" || log "Problems with ethernet connection. Aborting." err 1
    fi

    sed -Ei 's|^#?UseSyslog|UseSyslog|' /mnt/etc/pacman.conf
    sed -Ei 's|^#?Color|Color|' /mnt/etc/pacman.conf
    sed -Ei 's|^#?VerbosePkgLists|VerbosePkgLists|' /mnt/etc/pacman.conf
    sed -Ei 's|^#?ParallelDownloads.*|ParallelDownloads = 3|' /mnt/etc/pacman.conf
    sed -zi 's|#\[multilib\]\n#Include = \/etc\/pacman.d\/mirrorlist|\[multilib\]\nInclude = \/etc\/pacman.d\/mirrorlist|' /mnt/etc/pacman.conf

    if [[ -x /mnt/usr/bin/zsh ]]; then
        log "Making zsh the default shell"
        arch-chroot chsh -s /usr/bin/zsh
        arch-chroot chsh "$USER" -s /usr/bin/zsh
        echo 'ZDOTDIR="$HOME"/.config/zsh' >> /mnt/etc/zsh/zshenv
    fi

    deploy_swap
    deploy_localtime
    deploy_localization
    deploy_network
    deploy_apparmor
    deploy_users
    deploy_initramfs
    deploy_bootloader
    deploy_dotfiles
    deploy_unmount

    check_errors

    log "Looks like everything is done." warn
}
#+end_src

* Choosing Installation Step
#+begin_src bash
LONG_OPTS=help,stage:,user:,hostname:,setup:,display:,bootloader:,swap,encryption,archhost
SHORT_OPTS=S:u:h:g:d:b:sea
PARSED=$(getopt --options ${SHORT_OPTS} \
    --longoptions ${LONG_OPTS} \
    --name "$0" \
    -- "$@")
eval set -- "${PARSED}"

while true; do
    case "$1" in
        --help)
            help
            ;;
        -S|--stage)
            STAGE="$2"
            shift 2
            ;;
        -u|--user)
            USER="$2"
            shift 2
            ;;
        -h|--hostname)
            HOST_NAME="$2"
            shift 2
            ;;
        -g|--setup)
            SETUP="$2"
            shift 2
            ;;
        -d|--display)
            DISPLAY_SERVER="$2"
            shift 2
            ;;
        -b|--bootloader)
            BOOTLOADER="$2"
            shift 2
            ;;
        -s|--swap)
            ENABLE_SWAP_FILE=true
            shift
            ;;
        -e|--encryption)
            ENABLE_FULL_DRIVE_ENCRYPTION=true
            shift
            ;;
        -a|--archhost)
            IS_INSTALLING_FROM_EXISTING_ARCH=true
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Error while was passing the options"
            help
            ;;
    esac
done

if [[ $# -ne 1 ]]; then
    log "A single input file is required" err
    help
else
    readonly DRIVE="$1"
    ExtendDriveName "$DRIVE"
fi

case $STAGE in
    "fresh") deploy_init ;;
    "bootloader")
        deploy_bootloader
        deploy_unmount
        check_errors
        ;;
    *)
        log "Wrong options." err
        help
        ;;
esac
#+end_src

* TODO [0/3]
+ [ ] Auto-mounting on choosing the boot stage
+ [ ] Auto-figure swap size
+ [ ] Add 'clone' functionality in case of rather chosing to clone the entire system of host to another drive
